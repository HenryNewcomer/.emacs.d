
# ============================================================================
# ****************************************************************************
#+TITLE: Emacs Settings
#+AUTHOR: Henry Newcomer
# ****************************************************************************
# ============================================================================

* Startup
** Start timer

#+BEGIN_SRC emacs-lisp
(defconst emacs-start-time-settings (current-time))
#+END_SRC

** Set initial frame size for macOS
  This ensures that on macOS, Emacs will start with a window size
  that fills half the screen's width and the full height of the screen.

#+BEGIN_SRC emacs-lisp
(when (string-equal system-type "darwin")
  ;; Uncomment below to set a specific size.
  ;; (Setq initial-frame-alist '((top . 0) (left . 0) (height . 50) (width . 100)))
  ;; Start in fullscreen
  (add-to-list 'default-frame-alist '(fullscreen . maximized)))
#+END_SRC

** Garbage Collection
  Drastically increase the garbage collection until the end of
  this file. Afterwards, lower it back down.

Source: https://www.reddit.com/r/emacs/comments/3kqt6e/2_easy_little_known_steps_to_speed_up_emacs_start/

#+BEGIN_SRC emacs-lisp
(setq-default gc-cons-threshold 100000000)
#+END_SRC

** Operating System detection

Detects the current Operating System

#+BEGIN_SRC emacs-lisp
(defun henry:detect-os ()
"Detects the current system's Operating System."

  (setq henry:current-os-detected nil)

  (cond
  ((string-equal system-type "gnu/linux")
      (setq henry:current-os "Linux")
      (setq henry:current-os-detected t))
  ((string-equal system-type "windows-nt")
      (setq henry:current-os "Windows")
      (setq henry:current-os-detected t))
  ((string-equal system-type "darwin")
      (setq henry:current-os "OSX")
      (setq henry:current-os-detected t)))

(if henry:current-os-detected
  (progn
      (message (concat "Current OS detected: " henry:current-os)))
  (progn
      (message "Warning! OS detection failed!"))))

;; Initiates the function
(henry:detect-os)
#+END_SRC

** Add Homebrew paths for macOS

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (setenv "PATH" (concat "/opt/homebrew/bin:" (getenv "PATH")))
  (push "/opt/homebrew/bin" exec-path))
#+END_SRC

** Define <Leader> key

#+BEGIN_SRC emacs-lisp
(defvar <Leader> (make-sparse-keymap)
  "Keymap for custom \"<Leader>\" keybindings.")
#+END_SRC

** Package sources & initialization

#+BEGIN_SRC emacs-lisp
(require 'package)

(setq package-enable-at-startup nil)

;;(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
(setq package-archives
  '(("melpa" . "https://melpa.org/packages/")
    ("org"   . "https://orgmode.org/elpa/")
    ("gnu"   . "https://elpa.gnu.org/packages/")))
(package-initialize)
#+END_SRC

** Replace highlighted text when pasting

#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC


* Package Settings
** Check for package installations & upgrades

#+BEGIN_SRC emacs-lisp
;; Boostrap `use-package'
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
(package-install 'use-package))

(require 'use-package-ensure)
(setq use-package-always-ensure t)

(eval-when-compile
(require 'use-package))
#+END_SRC



** EVIL Mode

#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t
  :init
    (setq evil-want-C-u-scroll nil)
    (setq evil-want-integration t) ;; This is optional since it's already set to t by default.
    (setq evil-want-keybinding nil)
  :config
    (evil-mode 1)

    (define-key evil-normal-state-map (kbd "SPC") <Leader>)

    ;; Enhance the :w command to prompt for filename when needed
    (evil-ex-define-cmd "w[rite]"
      (lambda ()
        (interactive)
        (if (buffer-file-name)
            (evil-write nil nil)
          (let ((ido-enable-flex-matching nil))
            (call-interactively #'write-file)))))

    ;; Fix Dired help summary (key: `?`)
    (evil-define-key 'normal dired-mode-map (kbd "?") 'dired-summary)

    (evil-set-initial-state 'ibuffer-mode 'normal)

    (evil-set-undo-system 'undo-tree)

    (define-key evil-normal-state-map (kbd "O") 'henry:new-blank-line-above)
    (define-key evil-normal-state-map (kbd "o") 'henry:new-blank-line-below)


    ;; Sets Alt-j/k to move lines up or down
    (define-key evil-normal-state-map (kbd "M-k") 'henry:move-line-up)
    (define-key evil-normal-state-map (kbd "M-j") 'henry:move-line-down)

    ;; Allows the same keybindings to work within Insert mode
    (define-key evil-insert-state-map (kbd "M-k") 'henry:move-line-up)
    (define-key evil-insert-state-map (kbd "M-j") 'henry:move-line-down)


    ;; Resize window panes
    (define-key evil-normal-state-map (kbd "<M-up>") 'shrink-window)
    (define-key evil-normal-state-map (kbd "<M-down>") 'enlarge-window)
    (define-key evil-normal-state-map (kbd "<M-left>") 'shrink-window-horizontally)
    (define-key evil-normal-state-map (kbd "<M-right>") 'enlarge-window-horizontally)
)
#+END_SRC



** Aggressive Indent

Repo: https://github.com/Malabarba/aggressive-indent-mode

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :defer t
  :config
(global-aggressive-indent-mode 1)
;; TODO: Determine if I prefer HTML mode to use Aggressive Indent Mode or not
(add-to-list 'aggressive-indent-excluded-modes 'html-mode)

;; Prevents akward alignment blinkings within C++ Mode
(add-to-list
  'aggressive-indent-dont-indent-if
  '(and (derived-mode-p 'c++-mode)
     (null (string-match "\\([;{}]\\|\\b\\(if\\|for\\|while\\)\\b\\)"
             (thing-at-point 'line))))))
#+END_SRC


** Beacon

Repo: https://github.com/Malabarba/beacon

#+BEGIN_SRC emacs-lisp
(use-package beacon
:defer 4
  :config (beacon-mode 1))
#+END_SRC

** Clang Format

Repo: https://clang.llvm.org/docs/ClangFormat.html

#+BEGIN_SRC emacs-lisp
(use-package clang-format
  :defer 4
  :config
    (define-key <Leader> (kbd "c f") 'clang-format-region))

#+END_SRC

** Cmake Font Lock

Repo: https://github.com/Lindydancer/cmake-font-lock

#+BEGIN_SRC emacs-lisp
(use-package cmake-font-lock
  :defer t
  :config
    (autoload 'cmake-font-lock-activate "cmake-font-lock" nil t)
    (add-hook 'cmake-mode-hook 'cmake-font-lock-activate))
#+END_SRC

** Cmake IDE

#+BEGIN_SRC emacs-lisp
(use-package cmake-ide
  :defer 2
  :config
    (cmake-ide-setup))
#+END_SRC

** Column Enforce Mode

#+BEGIN_SRC emacs-lisp
(use-package column-enforce-mode
  :defer 8
  :config
    ;; Run this package, but disable it by default
    (column-enforce-mode -1)

    (setq column-enforce-column 80)

    ;; Customize the font style
    ;; (face-spec-set column-enforce-face '((t (:foreground "#ff2222" :bold t :underline t))))
    ;;(face-spec-set column-enforce-face '((t (:background "dark red"))))
)
#+END_SRC

** Company

Repo: http://company-mode.github.io/

TODO: Decide whether to use a keybinding or the delay...

#+BEGIN_SRC emacs-lisp
(use-package company
  :defer 8
  :config
(add-hook 'after-init-hook 'global-company-mode)
;; Set keybindings
(define-key evil-normal-state-map (kbd "<C-tab>") 'company-complete)
;;    (define-key evil-insert-state-map (kbd "<C-tab>") 'company-complete)

;; Show results immediately
(setq company-idle-delay 0))

#+END_SRC

** Copilot [WIP; disabled]

Repos:
 - https://github.com/copilot-emacs/copilot.el
 - https://github.com/jart/emacs-copilot

GitHub Copilot provides AI-powered code completion features within Emacs. It's based on binaries provided by copilot.vim and requires Node.js v18+.

+BEGIN_SRC emacs-lisp
  ;; Ensure quelpa and quelpa-use-package are installed and loaded
  (use-package copilot
    :quelpa (copilot :fetcher github :repo "copilot-emacs/copilot.el")
    :hook (prog-mode . copilot-mode)
    :config
    ;; Define Node.js executable path
    (setq copilot-node-executable (or (executable-find "node")
                                      "/usr/local/bin/node"  ;; macOS and most UNIX systems
                                      "/opt/homebrew/bin/node"))  ;; Homebrew on macOS

    ;; Custom login function to manually handle token input
    (defun copilot-login ()
      "Log in to GitHub Copilot."
      (interactive)
      (copilot--authenticate))

    ;; Ensure Copilot starts up on Emacs launch
    (add-hook 'emacs-startup-hook 'copilot-login)

    ;; Define keybindings for Copilot commands
    (evil-define-key 'insert copilot-mode-map (kbd "<tab>") 'copilot-accept-completion)
    (evil-define-key 'normal copilot-mode-map (kbd "<tab>") 'copilot-complete)
    (evil-define-key 'insert copilot-mode-map (kbd "C-<right>") 'copilot-accept-completion-by-word)
    (evil-define-key 'insert copilot-mode-map (kbd "C-<down>") 'copilot-accept-completion-by-line)
    (evil-define-key 'insert copilot-mode-map (kbd "M-<tab>") 'copilot-next-completion)
    (evil-define-key 'insert copilot-mode-map (kbd "M-S-<tab>") 'copilot-previous-completion)
    (evil-define-key 'normal copilot-mode-map (kbd "C-c C-x") 'copilot-clear-overlay)

    ;; Custom function for integrating Copilot with company-mode
    (defun my-tab ()
      "Complete by Copilot first, then fallback to company-mode."
      (interactive)
      (or (copilot-accept-completion)
          (company-indent-or-complete-common nil)))

    (evil-define-key 'insert copilot-mode-map (kbd "<tab>") 'my-tab)

    ;; Customize Copilot plugin settings
    (setq copilot-idle-delay 0.2)  ;; Delay before starting completion
    (setq copilot-max-char 100000)   ;; Maximum number of characters to send to Copilot

    ;; Set default model path (GitHub Copilot)
    (setq copilot-default-model-path nil)

    ;; Set local model path (replace with your desired model path)
    (setq copilot-local-model-path "~/models/microsoft/Phi-3-mini-4k-instruct-gguf/Phi-3-mini-4k-instruct-q4.gguf")

    ;; Function to switch between GitHub Copilot and local model
    (defun copilot-toggle-model ()
      "Toggle between GitHub Copilot and local model."
      (interactive)
      (if (null copilot-default-model-path)
          (progn
            (setq copilot-default-model-path copilot-local-model-path)
            (message "Switched to local model: %s" copilot-local-model-path))
        (setq copilot-default-model-path nil)
        (message "Switched to GitHub Copilot")))

    ;; Set the model path based on the default
    (setq copilot-model-path (or copilot-default-model-path copilot-local-model-path))

    ;; Enable Copilot globally
    (global-copilot-mode))

+END_SRC

**Note:** Ensure Node.js v18+ is installed on your system. The login function will prompt you for authentication on startup.

**Installation Steps:**
1. Install Node.js v18+.
2. Ensure `quelpa` and `quelpa-use-package` are installed.
3. Add the Copilot package and configuration to your Emacs init file.
4. Set the `copilot-local-model-path` variable to the path of your local model file.
5. Restart Emacs to initiate the Copilot login process.

**Switching between GitHub Copilot and Local Model:**
- You can use the `copilot-toggle-model` function to switch between GitHub Copilot and the local model.
- By default, GitHub Copilot is used. If the authentication fails or you want to use the local model, you can call `copilot-toggle-model` to switch to the local model.
- Calling `copilot-toggle-model` again will switch back to GitHub Copilot.

**Using Custom Local Models:**
- The provided configuration assumes you have downloaded a custom model file (e.g., `Phi-3-mini-4k-instruct-q4.gguf`) to a local directory (`~/models/microsoft/Phi-3-mini-4k-instruct-gguf/`).
- Set the `copilot-local-model-path` variable to the path of your local model file.
- Copilot will automatically detect and use the local model when `copilot-default-model-path` is set to `copilot-local-model-path`.

**Fixing the `copilot-max-char` Warning:**
- The `copilot-max-char` variable has been increased to `100000` to accommodate larger file sizes and avoid the warning message.

**Fixing the `cl` Package Deprecation Warning:**
- The `cl` package has been deprecated in favor of `cl-lib`. To fix the warning, you can replace any references to `cl` with `cl-lib` in your Emacs configuration.


** Counsel eTags

Repo: https://github.com/redguardtoo/counsel-etags

Settings based off of: https://gist.github.com/nilsdeppe/7645c096d93b005458d97d6874a91ea9

#+BEGIN_SRC emacs-lisp
(use-package counsel-etags
  :defer 6
  :config

(define-key evil-normal-state-map (kbd "M-.") 'counsel-etags-find-tag-at-point)
(define-key evil-normal-state-map (kbd "M-*") 'counsel-etags-grep-symbol-at-point)
(define-key evil-normal-state-map (kbd "M-f") 'counsel-etags-find-tag)

;; Ignore files above 1Mb
(setq counsel-etags-max-file-size 1024)

;; Ignore build directories
(eval-after-load 'counsel-etags
  '(progn
     ;; counsel-etags-ignore-directories does NOT support wildcast
     (add-to-list 'counsel-etags-ignore-directories "build")
     (add-to-list 'counsel-etags-ignore-directories ".vscode")
     ;; counsel-etags-ignore-filenames DOES support wildcast
     (add-to-list 'counsel-etags-ignore-filenames "TAGS")
     (add-to-list 'counsel-etags-ignore-filenames "*.clang-format")))

;; Don't ask before re-reading the TAGS files if they have changed
(setq tags-revert-without-query t)

;; Don't warn when TAGS files are large
;;(setq large-file-warning-threshold nil)

;; How many seconds to wait before rerunning tags for auto-update
(setq counsel-etags-update-interval 180)

;; Set up auto-update
(add-hook 'prog-mode-hook
  (lambda () (add-hook 'after-save-hook
               (lambda ()
                 (counsel-etags-virtual-update-tags))))))
#+END_SRC

** Dimmer

Repo: https://github.com/gonewest818/dimmer.el

#+BEGIN_SRC emacs-lisp
(use-package dimmer
  :defer 4
  :config (dimmer-mode))
#+END_SRC

** TODO Dumb Jump

Repo: https://github.com/jacktasia/dumb-jump

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :defer 8
  :config
(dumb-jump-mode)
;; TODO Think of better key bindings
(define-key <Leader> (kbd "C-8") 'dumb-jump-go)
(define-key <Leader> (kbd "C-*") 'dumb-jump-back))

#+END_SRC

** Elpy

Documents: https://elpy.readthedocs.io/en/latest/index.html

#+BEGIN_SRC emacs-lisp
(use-package elpy
  :ensure t
  :defer t
  :config
    ;; TODO : Think of better key-combos
    (define-key evil-normal-state-map (kbd "M-TAB") 'elpy-company-backend)
    (define-key <Leader> (kbd "p c") 'elpy-shell-send-region-or-buffer)
    (define-key <Leader> (kbd "p .") 'elpy-goto-definition-other-window)

    ;; Use standard Python interpreter
    (setq python-shell-interpreter "python"
          python-shell-interpreter-args "-i")
  :init
    (advice-add 'python-mode :before 'elpy-enable))

#+END_SRC

** TODO Emmet Mode

Repo: https://github.com/smihica/emmet-mode

TODO Edit or remove this package

#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :defer t
  :config
;;(add-hook 'sgml-mode-hook 'emmet-mode) ;; Auto-start on any markup modes
;;(add-hook 'css-mode-hook  'emmet-mode) ;; enable Emmet's css abbreviation.
)
#+END_SRC

** Esup

Repo: https://github.com/jschaf/esup

#+BEGIN_SRC emacs-lisp
(use-package esup
  :defer 8
  :config
    (define-key <Leader> (kbd "o e") 'esup))

#+END_SRC

** Evil Collection

Repo: https://github.com/emacs-evil/evil-collection

#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  :after evil
  :ensure t
  :config
  (evil-collection-init))
#+END_SRC

** TODO Evil Nerd Commenter

Repo: https://github.com/redguardtoo/evil-nerd-commenter

#+BEGIN_SRC emacs-lisp
  (use-package evil-nerd-commenter
    :defer 8
    :config
  (define-key <Leader> (kbd "/ /") 'evilnc-comment-or-uncomment-lines)
  (define-key <Leader> (kbd "/ l") 'evilnc-quick-comment-or-uncomment-to-the-line)
  (define-key <Leader> (kbd "/ y") 'evilnc-copy-and-comment-lines)
  (define-key <Leader> (kbd "/ p") 'evilnc-comment-or-uncomment-paragraphs)
  ;; TODO: This might need changed to use Visual Mode instead of Normal Mode
  (define-key evil-visual-state-map (kbd "SPC / r") 'comment-or-uncomment-region))
#+END_SRC

** TODO Evil Numbers

Repo: https://github.com/cofi/evil-numbers

(use-package evil-numbers
  :defer 8
  :config
(define-key evil-normal-state-map (kbd "C-c +") 'evil-numbers/inc-at-pt)
(define-key evil-normal-state-map (kbd "C-c -") 'evil-numbers/dec-at-pt))

** Evil Surround

Repo: https://github.com/emacs-evil/evil-surround

#+BEGIN_SRC emacs-lisp
(use-package evil-surround :defer 8)
#+END_SRC

** Flycheck

Repo: https://github.com/flycheck/flycheck

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :config
    (add-hook 'after-init-hook #'global-flycheck-mode))
#+END_SRC

** Flycheck Clang Analyzer

Repo: https://github.com/alexmurray/flycheck-clang-analyzer

#+BEGIN_SRC emacs-lisp
(use-package flycheck-clang-analyzer
  :after flycheck
  :config
      (flycheck-clang-analyzer-setup))
#+END_SRC

** Flycheck Inline

Repo: https://github.com/flycheck/flycheck-inline

#+BEGIN_SRC emacs-lisp
(use-package flycheck-inline
  :after flycheck
  :config
      (global-flycheck-inline-mode))
#+END_SRC

** Magit

Repo: https://github.com/magit/magit

#+BEGIN_SRC emacs-lisp
(use-package transient
  :ensure t)

(use-package magit
  :after transient
  :init
    (when (eq system-type 'darwin)
      (setq with-editor-emacsclient-executable "/opt/homebrew/bin/emacsclient"))
  :config
    (setq evil-magit-state 'normal)

    (define-key <Leader> "g" 'magit-status)
    (define-key <Leader> "G" 'magit-dispatch-popup)

    ;; After commits, close the leftover buffers
    ;; Source: https://emacs.stackexchange.com/questions/35775/how-to-kill-magit-diffs-buffers-on-quit

    (defun kill-magit-diff-buffer-in-current-repo (&rest _)
      "Delete the magit-diff buffer related to the current repo"
        (let ((magit-diff-buffer-in-current-repo
            (magit-mode-get-buffer 'magit-diff-mode)))
        (kill-buffer magit-diff-buffer-in-current-repo)))
    ;;
    ;; When 'C-c C-c' is pressed in the magit commit message buffer,
    ;; delete the magit-diff buffer related to the current repo.
    ;;
    (add-hook 'git-commit-setup-hook
      (lambda ()
        (add-hook 'with-editor-post-finish-hook
          #'kill-magit-diff-buffer-in-current-repo
          nil t))) ; the t is important
)
#+END_SRC

** Modern C++ Font Lock

Repo: https://github.com/ludwigpacifici/modern-cpp-font-lock

#+BEGIN_SRC emacs-lisp
(use-package modern-cpp-font-lock
  :defer t
  :hook (c++-mode-mode . modern-c++-font-lock-mode)
)
#+END_SRC

** Org Bullet

Repo: https://github.com/sabof/org-bullets

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :defer 2
  :config
    ;; Only customize the bullet symbols when on a Linux distro
    (cond
      ((string-equal system-type "darwin")
         (require 'org-bullets)
         (setq org-bullets-bullet-list
             '("❖" "✸" "✱" "◈"))
        (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
      ((string-equal system-type "gnu/linux")
         (require 'org-bullets)
         (setq org-bullets-bullet-list
             ;; Some examples: ❖✸✱❍◌◯⌗⌖⌑▓░▒❏❑▩◈◇
             '("✸" "◈" "✚" "○"))
        (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))))
#+END_SRC

** PHP Mode

#+BEGIN_SRC emacs-lisp
(use-package php-mode)
#+END_SRC

** TODO Parentheses, braces, & brackets pairs

** Rainbow Delimiters

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :defer 2
  :config
    (add-hook 'org-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
)
#+END_SRC

** Rainbow Mode

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :defer t
  :hook (prog-mode . rainbow-mode)
  :config
  (setq rainbow-x-colors nil)
  (setq rainbow-ansi-colors nil)
  (setq rainbow-html-colors t)
  (setq rainbow-latex-colors nil)
  (setq rainbow-r-colors nil))
#+END_SRC

** TODO Realgud

#+BEGIN_SRC emacs-lisp
(use-package realgud
  :defer 10
  :config
(define-key <Leader> (kbd "r d") 'realgud:gdb)
)
#+END_SRC

** FIXME Smartparens

FIXME I'm having issues with this after switching to use-package

Repo: https://github.com/Fuco1/smartparens

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :defer 2
  :config
;; Load default config
(require 'smartparens-config)
;; Enable smartparens mode
(show-smartparens-global-mode +1)
;; Keeps parens balanced
(smartparens-strict-mode)

;; NOTE I'm not sure what I did wrong with :hook but having these
;; hooks added here still work.
;;Manually add smartparens mode support for major modes
(add-hook 'org-mode-hook #'smartparens-mode)
(add-hook 'prog-mode-hook #'smartparens-mode)

;; C++
(sp-with-modes '(c++-mode)
  (sp-local-pair "{" nil :post-handlers '(("||\n[i]" "RET")))
  (sp-local-pair "/*" "*/" :post-handlers '((" | " "SPC")
                                             ("* ||\n[i]" "RET"))))
)
#+END_SRC

** Telephone Line

Repo: https://github.com/dbordak/telephone-line

#+BEGIN_SRC emacs-lisp
(use-package telephone-line
  :defer t
  :config
(setq telephone-line-primary-left-separator 'telephone-line-identity-left
  telephone-line-secondary-left-separator 'telephone-line-identity-hollow-left
  telephone-line-primary-right-separator 'telephone-line-identity-right
  telephone-line-secondary-right-separator 'telephone-line-identity-hollow-right)
(setq telephone-line-height 18)
(telephone-line-mode 1)

  ;; Configure telephone-line with Evil
  (defvar xah-fly-insert-state-p)
  (defun telephone-line-modal-face (active)
    "Return an appropriate face for the current mode, given whether the frame is ACTIVE."
    (cond ((not active) 'mode-line-inactive)
          ((bound-and-true-p xah-fly-keys)
           (if xah-fly-insert-state-p
               'telephone-line-evil-insert
             'telephone-line-evil-normal))
          ((not (bound-and-true-p evil-mode)) 'mode-line)
          (t (intern (concat "telephone-line-evil-" (symbol-name evil-state)))))))
#+END_SRC

** Transient

(Required for Magit)

#+BEGIN_SRC emacs-lisp
(setq package-install-upgrade-built-in t)
(package-install 'seq)
(progn (unload-feature 'seq t) (require 'seq))

(use-package transient)
#+END_SRC

** Undo Tree

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :config
    (global-undo-tree-mode 1)

    ;; Set up storage directory
    (setq undo-tree-history-directory-alist
	    `(("." . ,(concat user-emacs-directory "undo-tree-hist"))))

    ;; Create the directory if it doesn't exist
    (make-directory (concat user-emacs-directory "undo-tree-hist") t)

    ;; Function to clean old undo-tree files
    (defun henry:cleanup-undo-tree-history ()
	"Remove undo-tree files older than 7 days."
	(interactive)
	(let* ((undo-tree-dir (concat user-emacs-directory "undo-tree-hist"))
	    (days-to-keep 7)
	    (current-time (float-time (current-time)))
	    (age-limit (* days-to-keep 24 60 60)) ; convert days to seconds
	    (files-removed 0))
	(when (file-directory-p undo-tree-dir)
	    (dolist (file (directory-files undo-tree-dir t))
	    (when (and (file-regular-p file)
			(not (member (file-name-nondirectory file) '("." "..")))
			(> (- current-time (float-time (nth 5 (file-attributes file))))
			    age-limit))
		(delete-file file)
		(setq files-removed (1+ files-removed))))
	    (message "Removed %d old undo-tree history files" files-removed))))

    ;; Run cleanup every week when Emacs starts
    (defun henry:maybe-cleanup-undo-tree ()
	"Run cleanup if it hasn't been done in the last week."
	(let ((last-cleanup-file (concat user-emacs-directory "undo-tree-hist/.last-cleanup"))
	    (week-seconds (* 7 24 60 60)))
	(when (or (not (file-exists-p last-cleanup-file))
		    (> (- (float-time (current-time))
			(float-time (nth 5 (file-attributes last-cleanup-file))))
		    week-seconds))
	    ;; Do cleanup and update timestamp
	    (henry:cleanup-undo-tree-history)
        (with-temp-file last-cleanup-file
          (insert (format-time-string "%Y-%m-%d %H:%M:%S"))))))

  ;; Add cleanup to startup
  (add-hook 'after-init-hook #'henry:maybe-cleanup-undo-tree)

  (setq undo-tree-auto-save-history t
        undo-tree-save-history t
        undo-tree-enable-undo-in-region t
        undo-tree-check-timestamp t)

  ;; Maximum size for undo-tree files (in bytes)
  (setq undo-tree-auto-save-history-size-limit (* 64 1024 1024)) ; 64MB limit

  ;; Or disable saving for very large files
  (setq undo-tree-auto-save-history-limit 10000) ; Don't save for files with more than 10k nodes

  (define-key <Leader> (kbd "c u") 'henry:cleanup-undo-tree-history) ; "cleanup undo-tree"
  (define-key evil-normal-state-map (kbd "u") 'undo)
  (define-key evil-normal-state-map (kbd "C-r") 'undo-tree-redo)
  (define-key <Leader> (kbd "C-r") 'undo-tree-visualize))
#+END_SRC

** Web Mode

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :defer 2)
#+END_SRC

** YAScroll

#+BEGIN_SRC emacs-lisp
(use-package yascroll
  :defer 8
  :config
(global-yascroll-bar-mode 1)
)
#+END_SRC

** TODO YASnippet

Source: https://github.com/joaotavora/yasnippet

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :defer 8
  :config
;;    (yas-global-mode 1)
)
#+END_SRC



* General emacs settings
** Automatic backups

Source: https://www.emacswiki.org/emacs/ForceBackups

#+BEGIN_SRC emacs-lisp
;; Default and per-save backups go here:
(setq backup-directory-alist '(("" . "~/.emacs.d/backups/per-save")))

(defun force-backup-of-buffer ()
;; Make a special "per session" backup at the first save of each
;; emacs session.
(when (not buffer-backed-up)
    ;; Override the default parameters for per-session backups.
    (let ((backup-directory-alist '(("" . "~/.emacs.d/backups/per-session")))
        (kept-new-versions 3))
    (backup-buffer)))
;; Make a "per save" backup on each save.  The first save results in
;; both a per-session and a per-save backup, to keep the numbering
;; of per-save backups consistent.
(let ((buffer-backed-up nil))
    (backup-buffer)))

(add-hook 'before-save-hook  'force-backup-of-buffer)
#+END_SRC

** Cursor
*** Cursor settings

    Don't blink the cursor

#+BEGIN_SRC emacs-lisp
    (blink-cursor-mode -1)
#+END_SRC

*** Cursor between braces

    - Source: https://stackoverflow.com/questions/34087964/visual-studio-style-curly-brackets-auto-completion-in-emacs
#+BEGIN_SRC emacs-lisp
    (defun electric-pair-brace-fixup ()
      (when (and electric-pair-mode
              (if (functionp electric-pair-open-newline-between-pairs)
                (funcall electric-pair-open-newline-between-pairs)
                electric-pair-open-newline-between-pairs)
              (eq last-command-event ?\{)
              (= ?\{ (char-before)) (= ?\} (char-after)))
        (newline nil t)))

    (advice-add 'electric-pair-post-self-insert-function :after #'electric-pair-brace-fixup)
#+END_SRC

** C++

    Makes header files (.h) use C++ Mode rather than C Mode.

#+BEGIN_SRC emacs-lisp
    (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
#+END_SRC

** Column Enforce Mode (80-char Toggle)

#+BEGIN_SRC emacs-lisp
    (defun henry:custom-toggle-column-limit ()
      "Toggles the column limit from 80 to unlimited"
      (interactive)
      (if (get 'henry:custom-toggle-column-limit 'state)
        (progn
          (message "80-column limit indicator DISABLED.")
          (column-enforce-mode -1)
          (put 'henry:custom-toggle-column-limit 'state nil))
        (progn
          (message "80-column limit indicator ENABLED.")
          (column-enforce-mode t)
          (put 'henry:custom-toggle-column-limit 'state t))))

    ;; Toggle->Limit
    (define-key <Leader> (kbd "t l") 'henry:custom-toggle-column-limit)
#+END_SRC

** Copy Thing At Point or Region

#+BEGIN_SRC emacs-lisp
(defun henry:copy-thing-at-point-or-region ()
  "Copy the thing at point or the active region.
If a region is active, copy that region.
Otherwise, try to copy the thing at point, which could be:
- A symbol
- A line
- A sentence
- A paragraph
- Any text between matching delimiters (parentheses, brackets, etc.)"
  (interactive)
  (cond
   ;; If there's an active region, copy it
   ((use-region-p)
    (kill-ring-save (region-beginning) (region-end))
    (message "Region copied"))

   ;; Try to copy a symbol at point
   ((thing-at-point 'symbol)
    (kill-new (thing-at-point 'symbol))
    (message "Symbol copied"))

   ;; Try to copy delimited text (text between matching delimiters)
   ((thing-at-point 'list)
    (kill-new (thing-at-point 'list))
    (message "Delimited text copied"))

   ;; If not a symbol or delimited text, copy the current line
   (t
    (kill-ring-save (line-beginning-position) (line-end-position))
    (message "Current line copied")))

  ;; Optionally, you can add more conditions here for other types of "things"
  ;; For example, to copy a sentence or a paragraph
  )

;; Bind this function to a convenient key combination
(define-key <Leader> (kbd "y") 'henry:copy-thing-at-point-or-region)(defun henry:copy-thing-at-point-or-region ()
  "Copy the thing at point or the active region.
If a region is active, copy that region.
Otherwise, try to copy the thing at point, which could be:
- A symbol
- A line
- A sentence
- A paragraph
- Any text between matching delimiters (parentheses, brackets, etc.)"
  (interactive)
  (cond
   ;; If there's an active region, copy it
   ((use-region-p)
    (kill-ring-save (region-beginning) (region-end))
    (message "Region copied"))

   ;; Try to copy a symbol at point
   ((thing-at-point 'symbol)
    (kill-new (thing-at-point 'symbol))
    (message "Symbol copied"))

   ;; Try to copy delimited text (text between matching delimiters)
   ((thing-at-point 'list)
    (kill-new (thing-at-point 'list))
    (message "Delimited text copied"))

   ;; If not a symbol or delimited text, copy the current line
   (t
    (kill-ring-save (line-beginning-position) (line-end-position))
    (message "Current line copied")))

  ;; Optionally, you can add more conditions here for other types of "things"
  ;; For example, to copy a sentence or a paragraph
  )

;; Bind this function to a convenient key combination
(define-key <Leader> (kbd "y") 'henry:copy-thing-at-point-or-region)
#+END_SRC

** Dired Mode

    Auto-refresh dired on file change
#+BEGIN_SRC emacs-lisp
    (add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC

** Font settings
    Set default language and encodings

#+BEGIN_SRC emacs-lisp
    (setenv "LANG" "en_US.UTF-8")
    (setenv "LC_ALL" "en_US.UTF-8")
    (setenv "LC_CTYPE" "en_US")
    (set-locale-environment "English")
    (set-language-environment 'English)
    (prefer-coding-system 'utf-8)
    (set-buffer-file-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (set-selection-coding-system 'utf-8)
    (set-file-name-coding-system 'utf-8)
    (set-terminal-coding-system 'utf-8)
#+END_SRC

    Set default font

    TODO: See if fonts can be found with relative paths instead of being "installed"

#+BEGIN_SRC emacs-lisp
;;  (set-frame-font "Iosevka 11")
    (set-frame-font "Hack 11")
    (if
      (string-equal system-type "darwin")
      (set-frame-font "Fira Code 14")
      (set-frame-font "Hack 11"))
    ;; To prevent odd graphical glitching, keep the mode-line's size small
;;    (set-face-attribute 'mode-line nil :font "Iosevka-11")
#+END_SRC

** GDB (Debugger)

#+BEGIN_SRC emacs-lisp
    (setq gdb-many-windows t)
#+END_SRC

** Get font face over point

Source: https://stackoverflow.com/questions/1242352/get-font-face-under-cursor-in-emacs/1242366

FIXME: Only grabs hl-line at the moment

#+BEGIN_SRC emacs-lisp
(defun henry:face-over-point ()
  "Display information about the face at point, ignoring hl-line."
  (interactive)
  (let* ((pos (point))
         (face (or (get-char-property pos 'read-face-name)
                   (get-char-property pos 'face)))
         (face-list (if (listp face) face (list face)))
         (non-hl-face (seq-find (lambda (f) (not (eq f 'hl-line))) face-list))
         (face-name (or non-hl-face 'default))
         (face-attrs (face-all-attributes face-name (selected-frame))))
    (if face-name
        (message "Face: %s\nAttributes: %s" face-name face-attrs)
      (message "No face at point %d" pos))))

(define-key <Leader> (kbd "f f") 'henry:face-over-point)
#+END_SRC

** Highlights
*** Current Line

#+BEGIN_SRC emacs-lisp
    (global-hl-line-mode +1)
#+END_SRC

*** Keywords (ex. "TODO")
    Source: https://gist.github.com/nilsdeppe/7645c096d93b005458d97d6874a91ea9

#+BEGIN_SRC emacs-lisp
    (add-hook 'prog-mode-hook
      (lambda ()
        ;; Disabled in cmake-mode due to glitch (see Author's comment in source)
        (when (not (derived-mode-p 'cmake-mode))
          (font-lock-add-keywords nil
            '(("\\<\\(BUG\\|DONE\\|FIXME\\|NOTE\\|TEMP\\|TODO\\)"
                1 font-lock-warning-face t))))))
#+END_SRC

** Ido

#+BEGIN_SRC emacs-lisp
  ;; Source: https://www.masteringemacs.org/article/introduction-to-ido-mode
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (ido-mode 1)
  (setq ido-separator "\n")
  (setq ido-use-filename-at-point 'guess)
  (setq ido-create-new-buffer 'always)
  (setq ido-file-extensions-order '(".org" ".cpp" ".h" ".php" ".html" ".css"))
  ; Allow spaces in file names
  (setq ido-enable-space-matching t)
  ; Use underscore to represent spaces during completion
  (setq ido-space-match-char ?_)
  ; Allow . files to be shown
  (setq ido-enable-dot-prefix t)
  ; Disable TRAMP completion for better local file handling
  (setq ido-enable-tramp-completion nil)

  (add-hook 'ido-setup-hook
    (lambda ()
    (define-key ido-completion-map (kbd "SPC") 'self-insert-command)))

#+END_SRC

** Me (Henry)

Custom Functions

TODO: Move other custom functions *here*!

*** 1. Auto-replace smart quotes

#+BEGIN_SRC emacs-lisp
(defun henry:replace-smart-quotes-in-string (string)
  "Replace smart quotes in STRING with straight quotes."
  (when (stringp string)
    (let ((replaced (replace-regexp-in-string "[‘’]" "'"
                     (replace-regexp-in-string "[“”]" "\"" string))))
      (if (equal replaced string)
          string  ; Return original if no replacements made
        replaced))))

(defun henry:replace-smart-quotes-on-paste (orig-fun &rest args)
  "Advice to replace smart quotes with straight quotes on paste."
  (let* ((inhibit-message t)  ; Prevent "mark set" message
         (yanked-text (current-kill 0))
         (replaced-text (when yanked-text
                         (henry:replace-smart-quotes-in-string yanked-text))))
    (if replaced-text
        (progn
          (push-mark (point) t)  ; Set mark quietly
          (insert replaced-text)
          (setq deactivate-mark t))  ; Clear mark after insert
      (apply orig-fun args))))

(advice-add 'yank :around #'henry:replace-smart-quotes-on-paste)
#+END_SRC

*** 2. Find via Clipboard

#+BEGIN_SRC emacs-lisp
(defun henry:search-clipboard-content (&optional backwards)
  "Search for clipboard content, with wrap-around and cycling support.
If BACKWARDS is non-nil, search in reverse."
  (interactive)
  (let ((clipboard-text (gui-get-selection 'CLIPBOARD 'STRING)))
    (if (or (null clipboard-text) (string-empty-p clipboard-text))
        (message "Clipboard is empty. Copy something first.")
      (deactivate-mark)
      (let ((found (if backwards
                      (search-backward clipboard-text nil t)
                    (search-forward clipboard-text nil t))))
        (when (not found)
          ;; If not found, wrap around and try again
          (goto-char (if backwards (point-max) (point-min)))
          (setq found (if backwards
                         (search-backward clipboard-text nil t)
                       (search-forward clipboard-text nil t))))
        (when found
          (push-mark (if backwards (point) (match-beginning 0)))
          (when (eq major-mode 'org-mode)
            (org-reveal '(4)))
          (activate-mark)
          (message "Found and highlighted clipboard content."))))))

(defun henry:search-clipboard-backwards ()
  "Search backwards for clipboard content."
  (interactive)
  (henry:search-clipboard-content t))

;; Bind both forward and backward search
(define-key <Leader> (kbd "s c") 'henry:search-clipboard-content)
(define-key <Leader> (kbd "s C") 'henry:search-clipboard-backwards)  ; Capital C for backwards#+END_SRC

*** 3. Update Packages

#+BEGIN_SRC emacs-lisp
(defun henry:update-all-packages ()
  "Update all installed packages without confirmation."
  (interactive)
  (package-refresh-contents)
  (dolist (package (mapcar 'car package-alist))
    (unless (package-installed-p package)
      (package-install package)))
  (message "Package update complete!"))

(define-key <Leader> (kbd "p u") 'henry:update-all-packages)
#+END_SRC

*** 4. My personal info

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Henry Newcomer")
(setq user-mail-address "a.cliche.email@gmail.com")
#+END_SRC


** Org Mode
*** Customizes the colors
    Source: https://orgmode.org/manual/Faces-for-TODO-keywords.html

#+BEGIN_SRC emacs-lisp
    (setq org-todo-keyword-faces
        '(("TODO" . "#3399ff") ("STARTED" . "yellow")
            ("CANCELED" . (:foreground "blue" :weight bold))))
#+END_SRC

    Colorize key areas within Org Mode
    Source: https://zzamboni.org/post/beautifying-org-mode-in-emacs/

    TODO: Use more of source author's code:

#+BEGIN_SRC emacs-lisp
    (custom-theme-set-faces
      'user
      '(org-document-info         ((t (:foreground "dark orange"))))
      '(org-link                  ((t (:foreground "royal blue" :underline t))))
      '(org-tag                   ((t (:weight bold height 0.8))))
      '(org-verbatim               ((t (:weight bold height 0.8)))))

    ;; Original settings from source:
    ;; -----------------------------
    ;; (custom-theme-set-faces
    ;;  'user
    ;;  '(org-block                 ((t (:inherit fixed-pitch))))
    ;;  '(org-document-info         ((t (:foreground "dark orange"))))
    ;;  '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
    ;;  '(org-link                  ((t (:foreground "royal blue" :underline t))))
    ;;  '(org-meta-line             ((t (:inherit (font-lock-comment-face fixed-pitch)))))
    ;;  '(org-property-value        ((t (:inherit fixed-pitch))) t)
    ;;  '(org-special-keyword       ((t (:inherit (font-lock-comment-face fixed-pitch)))))
    ;;  '(org-tag                   ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
    ;;  '(org-verbatim              ((t (:inherit (shadow fixed-pitch))))))
#+END_SRC

*** Attempt to improve org-mode performance
    Source: https://www.reddit.com/r/emacs/comments/98flwy/does_anyone_know_a_good_alternative_to_orgbullets/

#+BEGIN_SRC emacs-lisp
    (setq inhibit-compacting-font-caches t)
#+END_SRC

*** Adjust indentation spacing

#+BEGIN_SRC emacs-lisp
;; Set org-mode specific indentation
(add-hook 'org-mode-hook
  (lambda ()
    (setq-local tab-width 2)
    (setq-local evil-shift-width 2)))
#+END_SRC

*** Extra Settings

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files
    '("/Users/henry/Library/Mobile Documents/com~apple~CloudDocs/Documents/notes/tasks.org"
      "/Users/henry/Library/Mobile Documents/com~apple~CloudDocs/Documents/notes/daily.org"))
  (setq org-agenda-start-with-log-mode t)
  (setq org-log-done t)
  (setq org-log-into-drawer t)
#+END_SRC

** Paragraphs / Sentences

"Sentences" don't need to be followed by two spaces.

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space 'nil)
#+END_SRC

** TODO Parentheses, braces, & brackets pairs

    NOTE: Disabled this to test out Smart Parens package.
#+BEGIN_SRC emacs-lisp
;;    (show-paren-mode 1)
;;    (setq show-paren-delay 0)

    ;;(require 'paren)
    ;;(set-face-background 'show-paren-match (face-background 'default))
    ;;(set-face-foreground 'show-paren-match "#def")
    ;;(set-face-attribute 'show-paren-match nil :weight 'extra-bold)
#+END_SRC

** Prompt for Y or N (not Yes or No)

#+BEGIN_SRC emacs-lisp
    (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** TODO Recent mode

#+BEGIN_SRC emacs-lisp
    (recentf-mode 1)
    (setq recentf-max-menu-items 25)
    (global-set-key "\C-x\ \C-r" 'recentf-open-files)
#+END_SRC

** TODO Relative line numbers (set custom colors)

#+BEGIN_SRC emacs-lisp
    (setq-default display-line-numbers 'relative
                display-line-numbers-type 'visual
                display-line-numbers-current-absolute t
                display-line-numbers-width 4
                display-line-numbers-widen t)
    (add-hook 'text-mode-hook #'display-line-numbers-mode)
    (add-hook 'prog-mode-hook #'display-line-numbers-mode)

    ;; Customize current line
    ;;(custom-set-faces '(line-number-current-line ((t :weight bold
    ;;                                                 :foreground "goldenrod"
    ;;                                                 :background "slate gray"))))
#+END_SRC

** Scrolling

#+BEGIN_SRC emacs-lisp
    (setq scroll-step 1)
    (setq scroll-sconservatively 10000)
    (setq auto-window-vscroll nil)
#+END_SRC

** Sessions: Save/Restore ("Desktop")

    Automatically save and restore sessions
    - Source: https://stackoverflow.com/questions/4477376/some-emacs-desktop-save-questions-how-to-change-it-to-save-in-emacs-d-emacs/4485083#4485083

#+BEGIN_SRC emacs-lisp
    (setq desktop-dirname         "~/.emacs.d/desktop/"
      desktop-base-file-name      "emacs.desktop"
      desktop-base-lock-name      "lock"
      desktop-restore-eager       6
      desktop-path                (list desktop-dirname)
      desktop-save                t
;;      desktop-load-locked-desktop nil
      desktop-auto-save-timeout   30)

    (desktop-save-mode 1)
#+END_SRC

    To prevent potential corruption when saving files (prior to reading them all),
    test if it's okay to do, first.
    - Source: https://emacs.stackexchange.com/questions/17529/emacs-desktop-save-mode-only-save-desktop-when-previous-desktop-was-fully-rest

#+BEGIN_SRC emacs-lisp
    (defvar henry:save-desktop nil
      "Should I save the desktop when Emacs is shutting down?")

    (add-hook 'desktop-after-read-hook
      (lambda () (setq henry:save-desktop t)))

    (advice-add 'desktop-save :around
      (lambda (fn &rest args)
              (if (bound-and-true-p henry:save-desktop)
                  (apply fn args))))
#+END_SRC

    Save current place within file

#+BEGIN_SRC emacs-lisp
    (save-place-mode 1)
#+END_SRC

** Sound

    Disable the alert bell sound effect
#+BEGIN_SRC emacs-lisp
    (setq ring-bell-function 'ignore)
#+END_SRC

** Startup

#+BEGIN_SRC emacs-lisp
    (setq inhibit-startup-message t)
    (setq initial-scratch-message nil)
#+END_SRC

** <TAB>s / indentation

#+BEGIN_SRC emacs-lisp
;; Custom function for indenting and de-indenting sections
(defun my-indent-region ()
  "Indent the selected region or the current line."
  (interactive)
  (if (region-active-p)
      (progn
        (indent-rigidly (region-beginning) (region-end) 4)
        (setq deactivate-mark nil))
    (indent-rigidly (line-beginning-position) (line-end-position) 4)))

(defun my-deindent-region ()
  "De-indent the selected region or the current line."
  (interactive)
  (if (region-active-p)
      (progn
        (indent-rigidly (region-beginning) (region-end) -4)
        (setq deactivate-mark nil))
    (indent-rigidly (line-beginning-position) (line-end-position) -4)))

;; Define keybindings for indenting and de-indenting
(evil-define-key 'normal 'global (kbd "<leader>s>") 'my-indent-region)
(evil-define-key 'normal 'global (kbd "<leader>s<") 'my-deindent-region)
(evil-define-key 'visual 'global (kbd "<leader>s>") 'my-indent-region)
(evil-define-key 'visual 'global (kbd "<leader>s<") 'my-deindent-region)
#+END_SRC

** TODO additional customizations ???

    # --------------------------------------------------- #
    # TODO: When I have time (or *ambition*), go through
    # and customize this usage instead:
    # --------------------------------------------------- #

    Source: http://blog.binchen.org/posts/easy-indentation-setup-in-emacs-for-web-development.html
##+BEGIN_SRC emacs-lisp
    (defun my-setup-indent (n)
        ;; java/c/c++
        (setq-local c-basic-offset n)
        ;; web development
        (setq-local coffee-tab-width n) ; coffeescript
        (setq-local javascript-indent-level n) ; javascript-mode
        (setq-local js-indent-level n) ; js-mode
        (setq-local js2-basic-offset n) ; js2-mode, in latest js2-mode, it's alias of js-indent-level
        (setq-local lisp-indent-offset n) ; (e)lisp
        (setq-local web-mode-markup-indent-offset n) ; web-mode, html tag in html file
        (setq-local web-mode-css-indent-offset n) ; web-mode, css in html file
        (setq-local web-mode-code-indent-offset n) ; web-mode, js code in html file
        (setq-local css-indent-offset n) ; css-mode
    )

    (defun my-office-code-style ()
        (interactive)
        (message "Office code style!")
        ;; use tab instead of space
        (setq-local indent-tabs-mode t)
        ;; indent 4 spaces width
        (my-setup-indent 4))

    (defun my-personal-code-style ()
        (interactive)
        (message "My personal code style!")
        ;; use space instead of tab
        (setq indent-tabs-mode nil)
        ;; indent 2 spaces width
        (my-setup-indent 2))

    (defun my-setup-develop-environment ()
        (interactive)
        (let ((proj-dir (file-name-directory (buffer-file-name))))
            ;; if hobby project path contains string "hobby-proj1"
            (if (string-match-p "hobby-proj1" proj-dir)
                (my-personal-code-style))

            ;; if commericial project path contains string "commerical-proj"
            (if (string-match-p "commerical-proj" proj-dir)
                (my-office-code-style))))

    ;; prog-mode-hook requires emacs24+
    (add-hook 'prog-mode-hook 'my-setup-develop-environment)
    ;; a few major-modes does NOT inherited from prog-mode
    (add-hook 'lua-mode-hook 'my-setup-develop-environment)
    (add-hook 'web-mode-hook 'my-setup-develop-environment)
##+END_SRC

** Theme (custom)

#+BEGIN_SRC emacs-lisp
(add-to-list 'custom-theme-load-path "~/.emacs.d/themes/verditer-theme/")
(load-theme 'verditer t t)
(enable-theme 'verditer)
;; Or, if you use `use-package', do something like this:
;;(use-package laguna-theme
;;  :init (progn (load-theme 'laguna t t))
;;  :defer t
;;  :ensure t)
#+END_SRC

** Tweak window UI
*** Disable the tool & menu bars

#+BEGIN_SRC emacs-lisp
    (menu-bar-mode -1)
    (tool-bar-mode -1)
#+END_SRC

*** Disable the scroll bars

#+BEGIN_SRC emacs-lisp
    (when (display-graphic-p)
      (scroll-bar-mode -1))
    ;; Hide the minibuffer window's scrollbar
    (set-window-scroll-bars (minibuffer-window) nil nil)
#+END_SRC

*** Disable welcome screen

#+BEGIN_SRC emacs-lisp
    (setq inhibit-startup-screen t)
#+END_SRC

*** Open Emacs as fullscreen by default

#+BEGIN_SRC emacs-lisp
    (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+END_SRC

*** Adjust window size [edit: why isn't fullscreen working, nor this?]

   Set the initial window size to half of the screen width and full height.

#+BEGIN_SRC emacs-lisp

(defun henry:set-initial-frame-size ()
  "Set the initial size of the frame to half of the screen width and full height."
  (when (display-graphic-p)
    (add-to-list 'initial-frame-alist `(width . ,(/ (display-pixel-width) 2 (frame-char-width))))
    (add-to-list 'initial-frame-alist `(height . ,(/ (display-pixel-height) (frame-char-height))))
    (add-to-list 'initial-frame-alist '(top . 0))
    (add-to-list 'initial-frame-alist '(left . 0))))

(add-hook 'emacs-startup-hook 'henry:set-initial-frame-size)
#+END_SRC


** Web browser (internal)
    Eww

#+BEGIN_SRC emacs-lisp
    (setq browse-url-browser-function 'eww-browse-url)
#+END_SRC

** Whitespace (trailing)

#+BEGIN_SRC emacs-lisp
    ;; Before each save, trim the excess whitespace
    (add-hook 'before-save-hook 'delete-trailing-whitespace)

    ;; Set to true by default
    (setq whitespace-style '(face tabs trailing))
    (global-whitespace-mode t)
#+END_SRC



* Keybindings
** Buffers
*** Close buffer

#+BEGIN_SRC emacs-lisp
    (define-key <Leader> (kbd "c b") (lambda () (interactive) (kill-this-buffer))) ;; Close->Buffer
    (define-key <Leader> (kbd "c o b") (lambda () (interactive) (call-interactively 'kill-buffer))) ;; Close->Other->Buffer [prompt buffer name]
#+END_SRC

*** Create empty buffer
    Source: http://ergoemacs.org/emacs/emacs_new_empty_buffer.html

#+BEGIN_SRC emacs-lisp
    (defun henry:new-empty-buffer ()
      "Create a new empty buffer.
       New buffer will be named “untitled” or “untitled<2>”, “untitled<3>”, etc.
       It returns the buffer (for elisp programing)."
     (interactive)
     (let (($buf (generate-new-buffer "Untitled")))
       (switch-to-buffer $buf)
       (funcall initial-major-mode)
       (setq buffer-offer-save t)
       $buf))

    (define-key <Leader> (kbd "n b") 'henry:new-empty-buffer)
#+END_SRC

*** Ibuffer
    Open Ibuffer

#+BEGIN_SRC emacs-lisp
    (define-key <Leader> (kbd "o b") 'ibuffer)
#+END_SRC

    Config Ibuffer settings

#+BEGIN_SRC emacs-lisp
    ;; Force Ibuffer to use Evil keybindings
;;    (evil-set-initial-state 'ibuffer-mode 'normal)
    ;; Prevents prompting for permission to delete unmodified buffers
    (setq ibuffer-expert t)
    ;; Don't show groups that are empty
    (setq ibuffer-show-empty-filter-groups nil)
#+END_SRC

    When opening Ibuffer, automatically highlight the most recent buffer.
    Source: https://stackoverflow.com/questions/3417438/close-all-buffers-besides-the-current-one-in-emacs

#+BEGIN_SRC emacs-lisp
    (defadvice ibuffer (around ibuffer-point-to-most-recent) ()
      "Open ibuffer with cursor pointed to most recent buffer name."
      (let ((recent-buffer-name (buffer-name)))
        ad-do-it
        (ibuffer-jump-to-buffer recent-buffer-name)))

    (ad-activate 'ibuffer)
#+END_SRC


    Kills all buffers besides the active one.
    Souce: https://www.emacswiki.org/emacs/KillingBuffers#toc2

#+BEGIN_SRC emacs-lisp
    (defun henry:kill-other-buffers ()
      "Kills all other buffers."
      (interactive)
      (mapc 'kill-buffer (delq (current-buffer) (buffer-list)))
      (message "Killed all of the other buffers!"))

    ;; Close->All (other)->Buffers
    (define-key <Leader> (kbd "c a b") 'henry:kill-other-buffers)
#+END_SRC

    Kills all Dired Mode buffers.
    Source: https://www.emacswiki.org/emacs/KillingBuffers#toc3

#+BEGIN_SRC emacs-lisp
    (defun henry:kill-dired-buffers ()
      "Kills all Dired Mode buffers."
      (interactive)
      (mapc (lambda (buffer)
              (when (eq 'dired-mode (buffer-local-value 'major-mode buffer))
                (kill-buffer buffer)))
            (buffer-list))
      (message "Killed Dired buffers!"))

    ;; Close->Dired->Buffers
    (define-key <Leader> (kbd "c d b") 'henry:kill-dired-buffers)
#+END_SRC

    Creates custom Ibuffer groups
    Based on: http://martinowen.net/blog/2010/02/03/tips-for-emacs-ibuffer.html

#+BEGIN_SRC emacs-lisp
    (setq ibuffer-saved-filter-groups
      '(("personal"
          ("C++" (mode . c++-mode))
;;          ("C++ Headers" (filename . "\*.h"))
;;          ("C++ Source Files" (filename . "\*.cpp"))
          ("Web Development" (or (mode . html-mode)
            (mode . css-mode)))
          ("Magit" (name . "\*magit"))
          ("Emacs Config/Settings" (or (filename . ".emacs")
            (filename . "settings.org")))
          ("Help" (or (name . "\*Help\*")
            (name . "\*Apropos\*")
            (name . "\*info\*"))))))

    (add-hook 'ibuffer-mode-hook
      '(lambda ()
        (ibuffer-auto-mode 1) ;; Keeps the buffer list up-to-date
        (ibuffer-switch-to-saved-filter-groups "personal")))

#+END_SRC

*** TODO Swap between previous buffer
    Source: https://emacsredux.com/blog/2013/04/28/switch-to-previous-buffer/

    TODO: Buffer List ruins this... Figure out a fix.

#+BEGIN_SRC emacs-lisp
    (defun henry:switch-to-previous-buffer ()
      "Switch to previously open buffer.

Repeated invocations toggle between the two most recently open buffers."
      (interactive)
      (switch-to-buffer (other-buffer (current-buffer) 1)))

    (define-key <Leader> (kbd "o o") 'henry:switch-to-previous-buffer) ; "Open Other"
#+END_SRC

*** Swap to *Scratch*
#+BEGIN_SRC emacs-lisp
    (defun henry:swap-to-scratch ()
      "Changes buffer to the *Scratch* buffer."
      (interactive)
      (switch-to-buffer "*scratch*"))
    (define-key <Leader> (kbd "s t s") 'henry:swap-to-scratch)
#+END_SRC

** Double space (Normal Mode)

#+BEGIN_SRC emacs-lisp
    (defun henry:double-space ()
      "Creates a single blank space when the space key is pressed twice; finishes in Evil's Normal Mode."
      (interactive)
      (evil-insert-state)
      (insert " ")
      (evil-normal-state))

    (define-key <Leader> (kbd "SPC") 'henry:double-space)
#+END_SRC

** Evaluate Elisp (sexp)

#+BEGIN_SRC emacs-lisp
    (defun henry:sexp-at-end-of-line ()
      "Jumps to the end of the line and runs 'eval-last-sexp'."
      (interactive)
      (move-end-of-line 1)
      (call-interactively 'eval-last-sexp))

    (define-key <Leader> (kbd "e l") 'henry:sexp-at-end-of-line)
#+END_SRC

** Find Name (Dired)

#+BEGIN_SRC emacs-lisp
;; Dired-related keybindings for search
(with-eval-after-load 'dired
  (define-key <Leader> (kbd "f n") 'find-name-dired))(define-key <Leader> (kbd "f n") 'find-name-dired)
#+END_SRC


** Line manipulations
*** Jump to beginning/end of line

#+BEGIN_SRC emacs-lisp
    ;; Think: Move->First/Last
    (define-key <Leader> (kbd "m f") (kbd "^"))
    (define-key <Leader> (kbd "m l") (kbd "$"))
#+END_SRC

*** Jump above or below current line

#+BEGIN_SRC emacs-lisp
    (defun henry:new-blank-line-above ()
      "Create blank line above cursor without entering Insert Mode."
      (interactive)
      (move-beginning-of-line nil)
      (newline)
      (forward-line -1))

    (defun henry:new-blank-line-below ()
      "Create blank line below cursor without entering Insert Mode."
      (interactive)
      (move-end-of-line nil)
      (newline))

    ;; (define-key evil-normal-state-map (kbd "O") 'henry:new-blank-line-above)
    ;; (define-key evil-normal-state-map (kbd "o") 'henry:new-blank-line-below)
#+END_SRC

*** Move current line up/down

    Source: https://www.emacswiki.org/emacs/MoveLine

#+BEGIN_SRC emacs-lisp
    (defmacro henry:move-line-save-column (&rest body)
      `(let ((column (current-column)))
         (unwind-protect
             (progn ,@body)
           (move-to-column column))))

    (put 'henry:move-line-save-column 'lisp-indent-function 0)

    (defun henry:move-line-up ()
      (interactive)
      (henry:move-line-save-column
        (transpose-lines 1)
        (forward-line -2)))

    (defun henry:move-line-down ()
      (interactive)
      (henry:move-line-save-column
        (forward-line 1)
        (transpose-lines 1)
        (forward-line -1)))

    ;; Sets Alt-j/k to move lines up or down
;;    (define-key evil-normal-state-map (kbd "M-k") 'henry:move-line-up)
;; (define-key evil-normal-state-map (kbd "M-j") 'henry:move-line-down)

    ;; Allows the same keybindings to work within Insert mode
;; (define-key evil-insert-state-map (kbd "M-k") 'henry:move-line-up)
;; (define-key evil-insert-state-map (kbd "M-j") 'henry:move-line-down)
#+END_SRC

** Org mode - shortcuts
#+BEGIN_SRC emacs-lisp
    (define-key <Leader> (kbd "o a") 'org-agenda)
    (define-key <Leader> (kbd "o s") 'org-schedule)
#+END_SRC

** Reload Emacs settings

#+BEGIN_SRC emacs-lisp
    (defun henry:reload-settings ()
      "Reload Emacs settings files"
      (interactive)
      (load "~/.emacs")
      (if (featurep 'copilot)
          (message "Emacs settings reloaded successfully, and Copilot is active!")
        (message "Emacs settings reloaded, but Copilot is not active. Please check your configuration.")))

    (define-key <Leader> (kbd "r s") 'henry:reload-settings)
#+END_SRC

** Save / quit

#+BEGIN_SRC emacs-lisp
    (define-key <Leader> (kbd "w") 'save-buffer) ;; Save
    (define-key <Leader> (kbd "c e") 'save-buffers-kill-terminal) ;; Close->Emacs
    (define-key <Leader> (kbd "W") 'write-file) ;; Save-As...
#+END_SRC

** TODO <TAB>s / indentation

    Indents a region of text

#+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "<C-M-tab>") 'indent-region)
#+END_SRC

    -----

TODO: Having issues making this. It's mostly to get elisp to tab with
2 spaces within Org mode, but it's not working properly. Maybe add
multiple major modes?

    Alternate between 2/4 tab widths

;;#+BEGIN_SRC emacs-lisp
    (defun henry:toggle-tab-widths ()
      "Toggles the tab widths between either 2 or 4 spaces.

By default, 4 are assumed. Toggling enables/disables 2 spaces."
      (interactive)
      (if (get 'henry:toggle-tab-widths 'using-two-spaces)
        (progn
          (setq-default tab-width 10)
          (setq-default tab-width 10)
          (message "Tab width set to: 4 spaces.")
          (put 'henry:toggle-tab-widths 'using-two-spaces nil))
        (progn
          (setq-default tab-width 2)
          (message "Tab width set to: 2 spaces.")
          (put 'henry:toggle-tab-widths 'using-two-spaces t))))

    ;; Toggle->Tab length
    (define-key <Leader> (kbd "t t") 'henry:toggle-tab-widths)
;;#+END_SRC

** Text Scaling

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-=") 'text-scale-increase)
(global-set-key (kbd "C-+") 'text-scale-decrease)
#+END_SRC

** Window management

#+BEGIN_SRC emacs-lisp
    ;; Think: Split->Horizontal or Vertical
    (define-key <Leader> (kbd "s h") '(lambda () (interactive) (progn (split-window-below) (other-window 1))))
    (define-key <Leader> (kbd "s v") '(lambda () (interactive) (progn (split-window-right) (other-window 1))))
#+END_SRC

    Move across split windows

#+BEGIN_SRC emacs-lisp
    (define-key <Leader> (kbd "h") 'windmove-left)
    (define-key <Leader> (kbd "l") 'windmove-right)
    (define-key <Leader> (kbd "j") 'windmove-down)
    (define-key <Leader> (kbd "k") 'windmove-up)
#+END_SRC

    Resize window panes

#+BEGIN_SRC emacs-lisp
;;    (define-key evil-normal-state-map (kbd "<M-up>") 'shrink-window)
;;    (define-key evil-normal-state-map (kbd "<M-down>") 'enlarge-window)
;;    (define-key evil-normal-state-map (kbd "<M-left>") 'shrink-window-horizontally)
;;    (define-key evil-normal-state-map (kbd "<M-right>") 'enlarge-window-horizontally)
#+END_SRC

    Close active window

#+BEGIN_SRC emacs-lisp
    (define-key <Leader> (kbd "c w") 'delete-window)

    (define-key <Leader> (kbd "S-j") #'other-window)
    (define-key <Leader> (kbd "S-k") #'prev-window)
    (defun prev-window ()
      (interactive)
      (other-window -1))
#+END_SRC

** Word wrap (toggle)

#+BEGIN_SRC emacs-lisp
    (define-key <Leader> (kbd "t w") 'toggle-truncate-lines)
#+END_SRC


** New/Open/Edit
*** Edit Settings (shortcut)

    TODO Check OS before trying to access settings file

#+BEGIN_SRC emacs-lisp
    ;; Think: Edit->Settings
    (define-key <Leader> (kbd "e s") (lambda()
      (interactive)
      (message "Loading Emacs Settings.org file...")
      (find-file "~/.emacs.d/settings.org")
      (message "Settings file loaded for editing.")))
#+END_SRC

*** File and folder management
**** Open Dired

#+BEGIN_SRC emacs-lisp
    (define-key <Leader> (kbd "o d") 'dired)
#+END_SRC

**** Open File

#+BEGIN_SRC emacs-lisp
    (define-key <Leader> (kbd "o f") 'find-file)
#+END_SRC

**** Open recent files

#+BEGIN_SRC emacs-lisp
    (define-key <Leader> (kbd "o r") 'recentf-open-files)
#+END_SRC

** TODO Terminal v2 <<<<<<<<<<

This function opens a terminal buffer in Emacs, with the ability to split
the window vertically or horizontally. It automatically detects and uses the
`zsh` shell if available, falling back to `bash` if `zsh` is not found.

Additionally, it sets up asynchronous process support using the `make-process`
function, allowing the terminal to run without blocking the Emacs UI.

If you prefer to always use `bash` instead of `zsh`, you can set the
`henry:default-shell` variable to "bash".

To use this function, you can call it with the following keybindings:

- <Leader> o t   - Open terminal in the current window
- <Leader> o v t - Open terminal in a new vertical split
- <Leader> o h t - Open terminal in a new horizontal split


#+BEGIN_SRC emacs-lisp
(defvar henry:default-shell nil
  "The default shell to use for the terminal buffer.
Set this to \"bash\" if you prefer to always use `bash` instead of `zsh`.")

(defun henry:detect-shell ()
  "Detect the preferred shell to use for the terminal buffer."
  (or henry:default-shell
      (when (executable-find "zsh") "zsh")
      "bash"))

(defun henry:open-terminal (&optional arg)
  "Open a Terminal buffer.

Passing \"v\" or \"h\" will split the window vertically or
horizontally, respectively."
  (interactive "sSplit window? (\"v\" or \"h\"):")
  (let ((shell (henry:detect-shell)))
    (cond
     ((string= arg "v")
      (progn
        (message "Opening Terminal (vertically).")
        (split-window-right)
        (other-window 1)))
     ((string= arg "h")
      (progn
        (message "Opening Terminal (horizontally).")
        (split-window-below)
        (other-window 1)))
     ((string= arg nil) (message "Opening Terminal.")))
    (let ((term-buffer (make-term "terminal" shell)))
      (switch-to-buffer term-buffer)
      ;; Set up async process support
      (set-process-filter (get-buffer-process term-buffer)
                          (lambda (proc string)
                            (when (buffer-live-p (process-buffer proc))
                              (with-current-buffer (process-buffer proc)
                                (insert string)
                                (run-with-idle-timer 0.1 nil 'henry:display-terminal-buffer))))))))

(defun henry:display-terminal-buffer ()
  "Display the terminal buffer after async process output."
  (display-buffer (current-buffer)))

(define-key <Leader> (kbd "o t") '(lambda () (interactive) (henry:open-terminal)))
(define-key <Leader> (kbd "o v t") '(lambda () (interactive) (henry:open-terminal "v")))
(define-key <Leader> (kbd "o h t") '(lambda () (interactive) (henry:open-terminal "h")))
#+END_SRC


** Toggles
*** DONE Comment/uncomment

    TODO Verify how well this works
    TODO Switch to NERD-Commenter

#+BEGIN_SRC emacs-lisp
    ;; Source: https://stackoverflow.com/questions/9688748/emacs-comment-uncomment-current-line
    (defun henry:toggle-comment-on-line ()
      "Comment or uncomment the current line"
      (interactive)
      (comment-or-uncomment-region (line-beginning-position) (line-end-position)))

;;    (define-key <Leader> (kbd "/") 'henry:toggle-comment-on-line)
#+END_SRC


* TODO Closure
** TODO: RE-ARRANGE THIS (AND RENAME?)

#+BEGIN_SRC emacs-lisp
(setq package-install-upgrade-built-in t)
#+END_SRC

** Reset Garbage Collector
#+BEGIN_SRC emacs-lisp
(run-with-idle-timer 5 nil (lambda ()
  (setq-default gc-cons-threshold 800000)
  (message "gc-cons-threshold restored to %s" gc-cons-threshold)))
#+END_SRC

** Show timer results

#+BEGIN_SRC emacs-lisp
(let ((elapsed (float-time (time-subtract (current-time)
                             emacs-start-time-settings))))
  (message " --- Loading %s...done (%.3fs)" load-file-name elapsed))

(add-hook 'after-init-hook
  `(lambda ()
     (let ((elapsed
             (float-time
               (time-subtract (current-time) emacs-start-time-settings))))
       (message " --- Loading %s...done (%.3fs) [after-init]"
         ,load-file-name elapsed))) t)
#+END_SRC

** Display a message when Emacs finishes loading

TODO: Include the timer results.

#+BEGIN_SRC emacs-lisp
(defun henry/display-startup-message ()
  "Display a message when Emacs finishes loading the settings."
  (message "*** Emacs finished instantiating. ✔ ***")
  (run-with-timer 5 nil (lambda () (message ""))))

(add-hook 'emacs-startup-hook 'henry/display-startup-message)
#+END_SRC
